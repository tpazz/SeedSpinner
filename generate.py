import itertools # For more advanced combinations if needed later, though not strictly used here yet
import tui

def _apply_capitalisation(word):
    """Generates capitalisation variations for a single word."""
    variations = {word.lower(), word.title(), word.upper()}
    variations.add(word) # Add the original form as well
    return list(variations)

def _apply_leet_speak(word):
    """Generates simple leet speak variations for a single word."""
    subs = {
        'a': ['@', '4'], 'A': ['@', '4'], # Removed original 'a' to ensure change if sub occurs
        'e': ['3'],      'E': ['3'],
        'i': ['1', '!'], 'I': ['1', '!'],
        'o': ['0'],      'O': ['0'],
        's': ['$', '5'], 'S': ['$', '5'],
        't': ['7'],      'T': ['7'],
    }
    forms = {word} # Always include the original form

    # --- Refined Leet Logic for more combinations ---
    # This is a basic recursive approach for simple leet.
    # It will generate more than the previous one but still not fully exhaustive for complex words.
    def generate_leets_recursive(current_word_list, index):
        if index == len(current_word_list):
            forms.add("".join(current_word_list))
            return

        original_char = current_word_list[index]
        generate_leets_recursive(list(current_word_list), index + 1) # Recurse with original char

        if original_char in subs:
            for sub_char in subs[original_char]:
                current_word_list[index] = sub_char
                generate_leets_recursive(list(current_word_list), index + 1) # Recurse with substituted char
                current_word_list[index] = original_char # Backtrack
    
    if any(c in subs for c in word): # Only run recursive if there are substitutable chars
        generate_leets_recursive(list(word), 0)

    # Fallback for very simple single substitutions if recursive is too much or for simple cases
    # (The recursive one should cover these if it works as intended)
    # if 'a' in word.lower(): forms.add(word.replace('a','@').replace('A','@'))
    # if 'e' in word.lower(): forms.add(word.replace('e','3').replace('E','3'))
    # if 'o' in word.lower(): forms.add(word.replace('o','0').replace('O','0'))
    # if 'i' in word.lower(): forms.add(word.replace('i','1').replace('I','1'))
    # if 's' in word.lower(): forms.add(word.replace('s','$').replace('S','$'))
    return list(forms)


def _apply_affixes(word):
    """Applies common suffixes and prefixes to a single word."""
    common_numbers = [str(i) for i in range(10)] + ["123", "007", "12345", "112233"]
    common_years = ["2022", "2023", "2024", "1990", "1995", "2000"]
    common_symbols = ["!", "@", "#", "$", "%", "^", "&", "*", "?", "_", "-"]
    all_affixes = common_numbers + common_years + common_symbols
    variations = {word}
    for affix in all_affixes:
        variations.add(word + affix)
        variations.add(affix + word)
    return list(variations)

# --- START OF MAJOR CHANGE AREA ---

def _generate_single_word_core_variations(base_word, mutation_config):
    """
    Generates Capitalisation and/or Leet Speak variations.
    If both are ON, Leet is applied to Capitalized versions.
    Affixes are NOT handled by this function.
    This function ALWAYS "combines" Caps and Leet if both are enabled.
    """
    # Start with the base word itself.
    # _apply_capitalisation already includes the original and lowercased versions.
    forms_after_caps = {base_word} # Ensure base_word is a starting point
    if mutation_config.get("capitalisation", False):
        forms_after_caps.update(_apply_capitalisation(base_word))
    else:
        forms_after_caps = {base_word.lower(), base_word} # If no caps, ensure at least lower and original

    # Now apply leet to all forms generated by capitalisation (or just the base_word/lower if caps was off)
    final_core_forms = set()
    if mutation_config.get("leet_speak", False):
        for form_cap in forms_after_caps:
            final_core_forms.update(_apply_leet_speak(form_cap))
    else:
        final_core_forms.update(forms_after_caps) # No leet speak, so use the forms after caps (or just base)

    return list(final_core_forms)


def generate_wordlist_logic(base_words, mutation_config, output_filename):
    """
    The main wordlist generation engine.
    Writes unique generated passwords to the output file.
    Returns the count of unique passwords written.
    Implicitly combines Caps and Leet if both enabled. Affixes are final.
    """
    if not base_words:
        print("\n[Error] No base words provided for generation.")
        return 0
    if not output_filename:
        print("\n[Error] Output filename not set.")
        return 0

    print(f"\nStarting wordlist generation for {len(base_words)} base word(s)...")
    print(f"Output will be saved to: {output_filename}")
    print("Enabled mutations:")
    enabled_mutations_display = []
    # Note: "combine_mutations" is removed from this display list
    for key, display_name in [
        ("capitalisation", "Capitalisation"), ("leet_speak", "Leet Speak"),
        ("concatenation", "Concatenation"), ("affixes", "Suffixes/Prefixes")
    ]:
        if mutation_config.get(key, False):
            enabled_mutations_display.append(display_name)
    if enabled_mutations_display:
        print(f"  - {', '.join(enabled_mutations_display)}")
        if mutation_config.get("capitalisation") and mutation_config.get("leet_speak"):
            print("    (Capitalisation and Leet Speak will be combined)")
    else:
        print("  - No mutations enabled (will output base words only).")

    unique_passwords_to_write = set()

    # This will store the core (Caps+Leet implicitly combined) forms used for concatenation.
    core_forms_for_concatenation_map = {}

    print("\nProcessing single-word variations (Caps/Leet, then Affixes)...")
    for i, base_word in enumerate(base_words):
        print(f"\rProcessing base word {i+1}/{len(base_words)}: '{base_word}' (Generated: {len(unique_passwords_to_write)})", end="")
        print()
        # Step 1a: Generate Core (Caps and/or Leet) Variations
        # _generate_single_word_core_variations now inherently "combines" caps and leet if both are ON.
        core_variations = _generate_single_word_core_variations(base_word, mutation_config)
        core_forms_for_concatenation_map[base_word] = core_variations # Save for concat

        # Step 1b: Apply Affixes to these Core Variations if 'affixes' is ON
        if mutation_config.get("affixes", False):
            forms_with_affixes = set()
            for core_form in core_variations: # core_variations are (Caps and/or Leet) forms
                forms_with_affixes.update(_apply_affixes(core_form))
            unique_passwords_to_write.update(forms_with_affixes)
        else:
            # If affixes are OFF, add the core_variations (Caps and/or Leet) directly
            unique_passwords_to_write.update(core_variations)
                
    print(f"\nAfter single-word variations: {len(unique_passwords_to_write)} unique forms.")


    # --- Concatenation ---
    if mutation_config.get("concatenation", False) and len(base_words) > 1:
        print("\nProcessing concatenations...")
        concat_pairs_processed_count = 0
        for i_idx in range(len(base_words)):
            for j_idx in range(len(base_words)):
                # Optional: skip self-concatenation if desired, e.g. if i_idx == j_idx: continue
                # For this example, let's allow self-concatenation to match previous behavior.
                # if i_idx == j_idx and len(base_words) > 1: continue # Example skip

                word1_base_for_concat = base_words[i_idx]
                word2_base_for_concat = base_words[j_idx]
                
                print(f"\rConcatenating components of '{word1_base_for_concat}' + '{word2_base_for_concat}'...", end="")
                print()
                # Use the CORE variations (Caps and/or Leet) generated earlier
                forms1_for_concat = core_forms_for_concatenation_map.get(word1_base_for_concat, [word1_base_for_concat])
                forms2_for_concat = core_forms_for_concatenation_map.get(word2_base_for_concat, [word2_base_for_concat])

                for v1_comp in forms1_for_concat:
                    for v2_comp in forms2_for_concat:
                        concatenated_word = v1_comp + v2_comp
                        
                        # Apply Affixes to the concatenated string IF 'affixes' is ON
                        if mutation_config.get("affixes", False):
                            unique_passwords_to_write.update(_apply_affixes(concatenated_word))
                        else:
                            unique_passwords_to_write.add(concatenated_word)
                        concat_pairs_processed_count +=1
            
            print(f"\rConcatenating components of '{word1_base_for_concat}' + ... (Unique total: {len(unique_passwords_to_write)})", end="")
            print()
        print(f"\nFinished processing concatenations. Processed ~{concat_pairs_processed_count} potential combined pairs.")

    # --- Writing to File ---
    print(f"\nAll processing complete. Writing {len(unique_passwords_to_write):,} unique passwords to file...")
    generated_count = 0 # Initialize before try block
    try:
        with open(output_filename, "w", encoding="utf-8") as f:
            final_list_to_write = list(unique_passwords_to_write)
            if len(final_list_to_write) < 5_000_000 : # Arbitrary threshold for sorting
                print("Sorting list before writing...")
                final_list_to_write.sort()

            for count, password in enumerate(final_list_to_write):
                f.write(password + "\n")
                if (count + 1) % 100000 == 0: # Progress update every 100k lines
                    print(f"\rWrote {count+1:,}/{len(final_list_to_write):,} passwords...", end="")

        generated_count = len(final_list_to_write)
        print(f"\rSuccessfully wrote {generated_count:,} unique passwords to '{output_filename}'.")
    except IOError as e:
        print(f"\n[Error] Failed to write to file '{output_filename}': {e}")
        return 0
    except Exception as e:
        print(f"\n[Error] An unexpected error occurred during file writing: {e}")
        return 0
    
    return generated_count

# --- END OF MAJOR CHANGE AREA ---

def trigger_wordlist_generation(state): # No change to this function's signature or calls
    """Handles the TUI option for generating the wordlist."""
    tui.clear_screen() # Changed from tui.clear_screen
    print("--- Generate Wordlist ---")

    base_words = state.get('words_for_engine', [])
    mutation_config = state.get('mutation_config', {}) # This config will no longer have 'combine_mutations'
    output_filename = state.get('output_filename', 'wordlist.txt')

    if not base_words:
        print("No words selected for the engine. Cannot generate.")
        print("Please enter seed words (Option 4) and use other options to configure.")
        tui.pause() # Changed from tui.pause
        return

    print(f"Base words for generation: {len(base_words)}")
    print(f"Mutation config: {mutation_config}") # For debugging, see what's passed
    print(f"Output file: {output_filename}")
    
    confirm = input("\nAre you sure you want to start generation? This might take time and disk space. (yes/no): ").strip().lower()
    if confirm == 'yes':
        count = generate_wordlist_logic(base_words, mutation_config, output_filename)
        if count > 0:
            print(f"\nGeneration complete. {count} passwords written.")
            # Here you would call entropy calculation if it's part of the tui.py
            # entropy_value = calculate_wordlist_char_entropy(output_filename)
            # if entropy_value is not None: print(f"Entropy: {entropy_value}")
        else:
            print("\nGeneration finished, but no passwords were written (or an error occurred).")
    else:
        print("\nGeneration cancelled.")
    tui.pause() # Changed from tui.pause